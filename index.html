<!-- Vakhtan - Russian draughts engine -->
<html lang="en" style="touch-action: none;">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<base href="bangladesh-checkers">
<style>
html { margin: 0; padding: 0; width: 100%; height: 100vh; background-color: white; }
body { padding: 0px; margin: 0px; font-family: monospace; font-size: 30px; background-color: #111; color: #aaa; }
button { -webkit-tap-highlight-color: transparent; width: 100%; height: 60px; padding: 3px; font-size: 22px; background-color: #111; color: #aaa; border: 1px solid #555; border-radius: 5px; cursor: pointer; }
button:hover { background: #444; }
button:active { background-color: black; color: white; } 
input, select { padding: 2px; font-size: 18px; background: #111; border: 1px solid #444; color: #aaa; border-radius: 5px; } 
input:focus { outline: none }
button:focus { outline: none }
.highlight { box-shadow: inset 0px 0px 10px 10px #ff0; }
</style>
</head>
<body>
<div id="game-container" style="display: flex; flex-direction: column; align-items: center; justify-content: center;  width: 100%; height: 100%;">
<div id="board"></div>
<input id="fen" type="text" spellcheck="false" value="W:Wa3,c3,e3,g3,b2,d2,f2,h2,a1,c1,e1,g1:Bb8,d8,f8,h8,a7,c7,e7,g7,b6,d6,f6,h6"/>
<div id="buttons" style="display: flex; justify-content: center; gap: 1px; margin-top: 10px;">
<select id="depth">
  <option value='3'>DUMB</option>
  <option value='5'>NOOB</option>
  <option value='7' selected>EASY</option>
  <option value='9'>MESS</option>
  <option value='11'>HARD</option>
  <option value='13'>EPIC</option>
</select>
<button id="play">PLAY</button>
<button id="edit">EDIT</button>
<button id="undo">UNDO</button>
<button id="move">MOVE</button>
<button id="flip">FLIP</button>
</div>
<div id="out"></div>
</div>
<script>
let width = window.innerWidth > window.innerHeight ? window.innerHeight : window.innerWidth;
let size = parseInt(width / (window.innerWidth > window.innerHeight ? 10 : 8.2 ));
let radius = size / 3;
let flip = 0;
let edit = 0;
var clickLock = 0;
var userSrc, userDst;

let blackMan = `
  <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="black circle">
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius}" fill="black" stroke="lightgrey" stroke-width="2"/>
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius-(radius/2)}" fill="none" stroke="lightgrey" stroke-width="2"/>
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius-(radius/4)}" fill="none" stroke="lightgrey" stroke-width="2"/>
  </svg>
`;

let whiteMan = `
  <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="black circle">
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius}" fill="white" stroke="black" stroke-width="2"/>
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius-(radius/2)}" fill="none" stroke="black" stroke-width="2"/>
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius-(radius/4)}" fill="none" stroke="black" stroke-width="2"/>
  </svg>
`;

let whiteKing = `
  <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="black circle">
    <circle cx=" ${size / 2}" cy="${size / 2}" r="${radius}" fill="white" stroke="#222" stroke-width="2"/>
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius-(radius/4)}" fill="none" stroke="black" stroke-width="2"/>
  </svg>
`;

let blackKing = `
  <svg width="${size}" height="${size}" viewBox="0 0 ${size} ${size}" role="img" aria-label="black circle">
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius}" fill="black" stroke="lightgrey" stroke-width="2"/>
    <circle cx="${size / 2}" cy="${size / 2}" r="${radius-(radius/4)}" fill="none" stroke="lightgrey" stroke-width="2"/>
  </svg>
`;

let emptySq = '<span style=\'visibility:hidden\'>' + whiteMan + '</span>';

const OCCUPIED = 0;
const WHITE = 1;
const BLACK = 2;
const MAN = 4;
const KING = 8;
const FREE = 16;
const CHANGECOLOR = 3;
const MAXMOVES = 50;
const MAXPLY = 64;
const INFINITY = 100000;
const WIN = 10000;

const startFen = 'W:Wa3,c3,e3,g3,b2,d2,f2,h2,a1,c1,e1,g1:Bb8,d8,f8,h8,a7,c7,e7,g7,b6,d6,f6,h6';
var b = new Array(46).fill(0);
var board = new Array(8).fill(0).map(() => new Array(8).fill(0));
var killerMoves = new Array(2 * MAXPLY);
var side = [];
var legalMoves = [];
var gameMoves = [];
var searchDepth = 7;
var nodes = 0;
var ply = 0;

const pieceScores = [0, 0, 0, 0, 0, 200, -200, 0, 0, 400, -400, 0, 0, 0, 0, 0, 0];

const pst = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 5, 5, 5, 0, 0,
  9, 9, 0, 0, 9, 9, 0, 0, 5, 5,
  5, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0
];

const testPositions = [
  'W:Wa7,a5,b4,c3,f2,h2,g1:Bb8,c7,e7,g7,g5,f4,h4:H0:F1',
  'W:Wd6,a3,g3,f2,h2,c1,g1:Bb8,f8,h8,b6,f6,h6,h4:H0:F1',
  'B:Wc5,e5,b4,a3,e3,f2,h2,g1:Bb8,h8,a7,c7,g7,h6,g5,h4:H0:F1',
  'W:Wc5,b4,d4,f4,a3,f2,h2,g1:Bd8,a7,e7,g7,d6,f6,h6,h4:H0:F1',
  'W:Wc5,e5,d4,g3,d2,f2,a1,c1,e1,g1:Bf8,h8,a7,c7,e7,g7,b6,h6,a5,g5:H0:F1',
  'B:Wb4,d4,f4,a3,e3,g3,b2,d2,f2,a1,e1,g1:Bb8,d8,f8,h8,a7,c7,e7,b6,h6,c5,g5,h4:H0:F1',
  'W:Wa5,d4,f4,a3,c3,e3,h2,c1:Bb8,a7,c7,b6,f6,h6,c5,g5:H0:F1',
  'W:Wg5,f4,h4,a3,e3,d2:Bf8,h8,e7,b6,d6,h6:H0:F1',
  'W:Wd4,f4,h4,a3,c3:Bd8,e7,b6,h6,c5:H0:F1',
  'W:Wd4,f4,a3,c3,e3,d2,f2,h2,c1,e1,g1:Bb8,d8,f8,h8,a7,b6,d6,h6,c5,g5,h4:H0:F1',
  'W:Wc5,d4,f4,h4,g3,h2,e1:Bf8,a7,e7,g7,d6,a5:H0:F1',
  'B:Wd4,f4,a3,e3,b2,f2,h2,e1,g1:Bb8,d8,h8,g7,b6,d6,h6,a5,c5,h4:H0:F1'
];

const m2coord = [
  'xx',
  'b8', 'd8', 'f8', 'h8',
  'a7', 'c7', 'e7', 'g7',
  'b6', 'd6', 'f6', 'h6',
  'a5', 'c5', 'e5', 'g5',
  'b4', 'd4', 'f4', 'h4',
  'a3', 'c3', 'e3', 'g3',
  'b2', 'd2', 'f2', 'h2',
  'a1', 'c1', 'e1', 'g1'
];

const coord2sq = {
  'h8':  5, 'f8':  6, 'd8':  7, 'b8': 8,
  'g7': 10, 'e7': 11, 'c7': 12, 'a7': 13,
  'h6': 14, 'f6': 15, 'd6': 16, 'b6': 17,
  'g5': 19, 'e5': 20, 'c5': 21, 'a5': 22,
  'h4': 23, 'f4': 24, 'd4': 25, 'b4': 26,
  'g3': 28, 'e3': 29, 'c3': 30, 'a3': 31,
  'h2': 32, 'f2': 33, 'd2': 34, 'b2': 35,
  'g1': 37, 'e1': 38, 'c1': 39, 'a1': 40
}

const sq2coord = {
   5: 'h8',  6: 'f8',  7: 'd8',  8: 'b8',
  10: 'g7', 11: 'e7', 12: 'c7', 13: 'a7',
  14: 'h6', 15: 'f6', 16: 'd6', 17: 'b6',
  19: 'g5', 20: 'e5', 21: 'c5', 22: 'a5',
  23: 'h4', 24: 'f4', 25: 'd4', 26: 'b4',
  28: 'g3', 29: 'e3', 30: 'c3', 31: 'a3',
  32: 'h2', 33: 'f2', 34: 'd2', 35: 'b2',
  37: 'g1', 38: 'e1', 39: 'c1', 40: 'a1'
}

function printBoard() {
  brd2dsp();
  let boardStr = '';
  let pieces = { 5: 'o', 6: 'x', 9: 'O', 10: 'X', 16: '.'};
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      if (col == 0) boardStr += (8-row)
      boardStr += ' ' + pieces[board[7-col][row]];
    } boardStr += '\n';
  } boardStr += '  a b c d e f g h';
  console.log(boardStr);
}

function printMoveList(moveList, n) {
  for (let i = 0; i < n; i++) console.log(move2str(moveList[i]));
}

function print(msg) {
  let out =  document.getElementById('out');
  out.innerHTML += '&nbsp' + msg + '<br>';
  out.scrollTop = out.scrollHeight;
}

function move2str(move) {
  let j;
  let src = move.m[0] % 256;
  let dst = move.m[1] % 256;
  src = src-parseInt(src/9);
  dst = dst-parseInt(dst/9);
  src -= 5; dst -= 5;
  j = src%4; src -= j; j = 3-j; src += j;
  j = dst%4; dst -= j; j = 3-j; dst += j;
  src++; dst++;
  let c = '-';
  if(move.l > 2) c = 'x';
  return m2coord[src]+c+m2coord[dst];
}

function parseFen(fen, color) {
  b = new Array(46).fill(0);
  board = new Array(8).fill(0).map(() => new Array(8).fill(0));
  color[0] = fen[0] == 'W' ? WHITE : BLACK;
  let i = 2;
  let pce = WHITE;
  let rank = MAN;
  while (i < fen.length) {
    let c = fen[i];
    var row, col;
    switch(c) {
      case 'B': pce = BLACK; break;
      case 'K': rank = KING;
      case 'a': row = 7; break;
      case 'b': row = 6; break;
      case 'c': row = 5; break;
      case 'd': row = 4; break;
      case 'e': row = 3; break;
      case 'f': row = 2; break;
      case 'g': row = 1; break;
      case 'h': row = 0; break;
      case '1': col = 7; break;
      case '2': col = 6; break;
      case '3': col = 5; break;
      case '4': col = 4; break;
      case '5': col = 3; break;
      case '6': col = 2; break;
      case '7': col = 1; break;
      case '8': col = 0; break;
      case ':':
      case ',':
        board[row][col] = pce|rank;
        rank = MAN;
        break;
    } i++;
    if (i == fen.length) board[row][col] = pce|rank;
  } dsp2brd();
}

function clearDisplay() {
  for (let row = 0; row < 8; row++)
    for (let col = 0; col < 8; col++)
      board[row][col] = FREE;
}

function dsp2brd() {
  for(let sq = 0; sq < 46; sq++) b[sq] = OCCUPIED;
  for(let sq = 5; sq <= 40; sq++) b[sq] = FREE;
  b[ 5]=board[0][0];b[ 6]=board[2][0];b[ 7]=board[4][0];b[ 8]=board[6][0];
  b[10]=board[1][1];b[11]=board[3][1];b[12]=board[5][1];b[13]=board[7][1];
  b[14]=board[0][2];b[15]=board[2][2];b[16]=board[4][2];b[17]=board[6][2];
  b[19]=board[1][3];b[20]=board[3][3];b[21]=board[5][3];b[22]=board[7][3];
  b[23]=board[0][4];b[24]=board[2][4];b[25]=board[4][4];b[26]=board[6][4];
  b[28]=board[1][5];b[29]=board[3][5];b[30]=board[5][5];b[31]=board[7][5];
  b[32]=board[0][6];b[33]=board[2][6];b[34]=board[4][6];b[35]=board[6][6];
  b[37]=board[1][7];b[38]=board[3][7];b[39]=board[5][7];b[40]=board[7][7];
  for(let sq = 5; sq <= 40; sq++) if (b[sq] == 0) b[sq] = FREE;
  for(let sq = 9; sq <= 36; sq += 9) b[sq] = OCCUPIED;
}

function brd2dsp() {
  clearDisplay();
  board[0][0]=b[5];board[2][0]=b[6];board[4][0]=b[7];board[6][0]=b[8];
  board[1][1]=b[10];board[3][1]=b[11];board[5][1]=b[12];board[7][1]=b[13];
  board[0][2]=b[14];board[2][2]=b[15];board[4][2]=b[16];board[6][2]=b[17];
  board[1][3]=b[19];board[3][3]=b[20];board[5][3]=b[21];board[7][3]=b[22];
  board[0][4]=b[23];board[2][4]=b[24];board[4][4]=b[25];board[6][4]=b[26];
  board[1][5]=b[28];board[3][5]=b[29];board[5][5]=b[30];board[7][5]=b[31];
  board[0][6]=b[32];board[2][6]=b[33];board[4][6]=b[34];board[6][6]=b[35];
  board[1][7]=b[37];board[3][7]=b[38];board[5][7]=b[39];board[7][7]=b[40];
}

function createMove() {
  return {l: 0, m: new Array(10).fill(0), path: new Array(10).fill(0), score: 0};
}

function createMoveList() {
  let moveList = [];
  for (let i = 0; i < MAXMOVES; i++) moveList.push(createMove());
  return moveList;
}

function generateQuiets(moveList, color) {
  let m = 0, temp = 0, n = 0;
  if (color == BLACK) {
    for (let sq = 5; sq <= 40; sq++) {
      if ((b[sq] & BLACK) != 0) {
        if ((b[sq] & MAN) != 0) {
          if ((b[sq+4] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            if (sq >= 32) m = (BLACK|KING); else m = (BLACK|MAN);
            m = m << 8;  m += (sq+4); moveList[n].m[1] = m;
            m = (BLACK|MAN); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++;
          }
          if ((b[sq+5] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            if (sq >= 32) m = (BLACK|KING); else m = (BLACK|MAN);
            m = m << 8;  m += (sq+5); moveList[n].m[1] = m;
            m = (BLACK|MAN); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++;
          }
        }
        if ((b[sq] & KING) != 0) {
          temp = sq; temp += 4;
          while((b[temp] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            m = (BLACK|KING); m = m << 8; m += temp; moveList[n].m[1] = m;
            m = (BLACK|KING); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++; temp += 4;
          }
          temp = sq; temp += 5;
          while((b[temp] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            m = (BLACK|KING); m = m << 8; m += temp; moveList[n].m[1] = m;
            m = (BLACK|KING); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++; temp += 5;
          }
          temp = sq; temp -= 4;
          while((b[temp] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            m = (BLACK|KING); m = m << 8; m += temp; moveList[n].m[1] = m;
            m = (BLACK|KING); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++; temp -= 4;
          }
          temp = sq; temp -= 5;
          while((b[temp] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            m = (BLACK|KING); m = m << 8; m += temp; moveList[n].m[1] = m;
            m = (BLACK|KING); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++; temp -= 5;
          }
        }
      }
    }
  }
  if (color == WHITE) {
    for (let sq = 5; sq <= 40; sq++) {
      if ((b[sq] & WHITE) != 0) {
        if ((b[sq] & MAN) != 0) {
          if ((b[sq-4] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            if (sq <= 13) m = (WHITE|KING); else m = (WHITE|MAN);
            m = m << 8;  m += (sq-4); moveList[n].m[1] = m;
            m = (WHITE|MAN); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++;
          }
          if ((b[sq-5] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            if (sq <= 13) m = (WHITE|KING); else m = (WHITE|MAN);
            m = m << 8;  m += (sq-5); moveList[n].m[1] = m;
            m = (WHITE|MAN); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++;
          }
        }
        if ((b[sq] & KING) != 0) {
          temp = sq; temp += 4;
          while((b[temp] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            m = (WHITE|KING); m = m << 8; m += temp; moveList[n].m[1] = m;
            m = (WHITE|KING); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++; temp += 4;
          }
          temp = sq; temp += 5;
          while((b[temp] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            m = (WHITE|KING); m = m << 8; m += temp; moveList[n].m[1] = m;
            m = (WHITE|KING); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++; temp += 5;
          }
          temp = sq; temp -= 4;
          while((b[temp] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            m = (WHITE|KING); m = m << 8; m += temp; moveList[n].m[1] = m;
            m = (WHITE|KING); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++; temp -= 4;
          }
          temp = sq; temp -= 5;
          while((b[temp] & FREE) != 0) {
            let move = createMove(); move.l = 2;
            m = (WHITE|KING); m = m << 8; m += temp; moveList[n].m[1] = m;
            m = (WHITE|KING); m = m << 8; m += sq; moveList[n].m[0] = m;
            n++; temp -= 5;
          }
        }
      }
    }
  } return n;
}

function generateCaptures(moveList, color) {
  let n = [0];
  let sq, tmp, temp, capSq, foundPd;
  if (color == BLACK) {
    for (sq = 5; sq <= 40; sq++) {
      if ((b[sq] & BLACK) != 0) {
        if ((b[sq] & MAN) != 0) {
          b[sq] = FREE;
          if ((b[sq+4] & WHITE) != 0) {
            if (b[sq+8] & FREE ) {
              moveList[n[0]].l = 3;
              moveList[n[0]].path[1] = (sq+8);
              m = (BLACK|MAN); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
              m = b[sq+4]; m = m << 8; m += (sq+4); moveList[n[0]].m[2] = m;
              if (sq >= 28) {
                m = (BLACK|KING); m = m << 8; m += (sq+8); moveList[n[0]].m[1] = m;
                tmp = b[sq+4]; b[sq+4] = OCCUPIED;
                blackKingCapture(n, moveList, sq+8);
                b[sq+4] = tmp;
              } else {
                m = (BLACK|MAN); m = m << 8; m += (sq+8); moveList[n[0]].m[1] = m;
                tmp = b[sq+4]; b[sq+4] = OCCUPIED;
                blackManCapture(n, moveList, sq+8);
                b[sq+4] = tmp;
              }
            }
          }
          if ((b[sq+5] & WHITE) != 0) {
            if (b[sq+10] & FREE ) {
              moveList[n[0]].l = 3;
              moveList[n[0]].path[1] = (sq+10);
              m = (BLACK|MAN); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
              m = b[sq+5]; m = m << 8; m += (sq+5); moveList[n[0]].m[2] = m;
              if (sq >= 28) {
                m = (BLACK|KING); m = m << 8; m += (sq+10); moveList[n[0]].m[1] = m;
                tmp = b[sq+5]; b[sq+5] = OCCUPIED;
                blackKingCapture(n, moveList, sq+10);
                b[sq+5] = tmp;
              } else {
                m = (BLACK|MAN); m = m << 8; m += (sq+10); moveList[n[0]].m[1] = m;
                tmp = b[sq+5]; b[sq+5] = OCCUPIED;
                blackManCapture(n, moveList, sq+10);
                b[sq+5] = tmp;
              }
            }
          }
          if ((b[sq-4] & WHITE) != 0) {
            if (b[sq-8] & FREE ) {
              moveList[n[0]].l = 3;
              moveList[n[0]].path[1] = (sq-8);
              m = (BLACK|MAN); m = m << 8; m += (sq-8); moveList[n[0]].m[1] = m;
              m = (BLACK|MAN); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
              m = b[sq-4]; m = m << 8; m += (sq-4); moveList[n[0]].m[2] = m;
              tmp = b[sq-4]; b[sq-4] = OCCUPIED;
              blackManCapture(n, moveList, sq-8);
              b[sq-4] = tmp;
            }
          }
          if ((b[sq-5] & WHITE) != 0) {
            if (b[sq-10] & FREE ) {
              moveList[n[0]].l = 3;
              moveList[n[0]].path[1] = (sq-10);
              m = (BLACK|MAN); m = m << 8; m += (sq-10); moveList[n[0]].m[1] = m;
              m = (BLACK|MAN); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
              m = b[sq-5]; m = m << 8; m += (sq-5); moveList[n[0]].m[2] = m;
              tmp = b[sq-5]; b[sq-5] = OCCUPIED;
              blackManCapture(n, moveList, sq-10);
              b[sq-5] = tmp;
            }
          } b[sq] = (BLACK|MAN);
        }
        if ((b[sq] & KING) != 0) {
          b[sq] = FREE;
          temp = sq;
          foundPd = 0;
          do temp += 4
          while((b[temp] & FREE) != 0);
          if ((b[temp] & WHITE) != 0) {
            capSq = temp;
            temp += 4;
            while((b[temp] & FREE) != 0) {
              if (testFrom13b(temp)) {
                foundPd = 1;
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (BLACK|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (BLACK|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                blackKingCapture(n, moveList, temp);
                b[capSq] = tmp;
              } temp += 4;
            }
            if (!foundPd) {
              temp = capSq;
              temp += 4;
              while((b[temp] & FREE) != 0) {
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (BLACK|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (BLACK|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                blackKingCapture(n, moveList, temp);
                b[capSq] = tmp;
                temp += 4;
              }
            }
          }
          temp = sq;
          foundPd = 0;
          do temp += 5
          while((b[temp] & FREE) != 0);
          if ((b[temp] & WHITE) != 0) {
            capSq = temp;
            temp += 5;
            while((b[temp] & FREE) != 0) {
              if (testFrom02b(temp)) {
                foundPd = 1;
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (BLACK|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (BLACK|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                blackKingCapture(n, moveList, temp);
                b[capSq] = tmp;
              } temp += 5;
            }
            if (!foundPd) {
              temp = capSq;
              temp += 5;
              while((b[temp] & FREE) != 0) {
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (BLACK|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (BLACK|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                blackKingCapture(n, moveList, temp);
                b[capSq] = tmp;
                temp += 5;
              }
            }
          }
          temp = sq;
          foundPd = 0;
          do temp -= 4
          while((b[temp] & FREE) != 0);
          if ((b[temp] & WHITE) != 0) {
            capSq = temp;
            temp -= 4;
            while((b[temp] & FREE) != 0) {
              if (testFrom13b(temp)) {
                foundPd = 1;
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (BLACK|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (BLACK|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                blackKingCapture(n, moveList, temp);
                b[capSq] = tmp;
              } temp -= 4;
            }
            if (!foundPd) {
              temp = capSq;
              temp -= 4;
              while((b[temp] & FREE) != 0) {
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (BLACK|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (BLACK|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                blackKingCapture(n, moveList, temp);
                b[capSq] = tmp;
                temp -= 4;
              }
            }
          }
          temp = sq;
          foundPd = 0;
          do temp -= 5
          while((b[temp] & FREE) != 0);
          if ((b[temp] & WHITE) != 0) {
            capSq = temp;
            temp -= 5;
            while((b[temp] & FREE) != 0) {
              if (testFrom02b(temp)) {
                foundPd = 1;
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (BLACK|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (BLACK|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                blackKingCapture(n, moveList, temp);
                b[capSq] = tmp;
              } temp -= 5;
            }
            if (!foundPd) {
              temp = capSq;
              temp -= 5;
              while((b[temp] & FREE) != 0) {
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (BLACK|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (BLACK|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                blackKingCapture(n, moveList, temp);
                b[capSq] = tmp;
                temp -= 5;
              }
            }
          } b[sq] = (BLACK|KING);
        }
      }
    }
  }
  if (color == WHITE) {
    for (sq = 5; sq <= 40; sq++) {
      if ((b[sq] & WHITE) != 0) {
        if ((b[sq] & MAN) != 0) {
          b[sq] = FREE;
          if ((b[sq+4] & BLACK) != 0) {
            if (b[sq+8] & FREE ) {
              moveList[n[0]].l = 3;
              moveList[n[0]].path[1] = (sq+8);
              m = (WHITE|MAN); m = m << 8; m += (sq+8); moveList[n[0]].m[1] = m;
              m = (WHITE|MAN); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
              m = b[sq+4]; m = m << 8; m += (sq+4); moveList[n[0]].m[2] = m;
              tmp = b[sq+4]; b[sq+4] = OCCUPIED;
              whiteManCapture(n, moveList, sq+8);
              b[sq+4] = tmp;
            }
          }
          if ((b[sq+5] & BLACK) != 0) {
            if (b[sq+10] & FREE ) {
              moveList[n[0]].l = 3;
              moveList[n[0]].path[1] = (sq+10);
              m = (WHITE|MAN); m = m << 8; m += (sq+10); moveList[n[0]].m[1] = m;
              m = (WHITE|MAN); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
              m = b[sq+5]; m = m << 8; m += (sq+5); moveList[n[0]].m[2] = m;
              tmp = b[sq+5]; b[sq+5] = OCCUPIED;
              whiteManCapture(n, moveList, sq+10);
              b[sq+5] = tmp;
            }
          }
          if ((b[sq-4] & BLACK) != 0) {
            if (b[sq-8] & FREE ) {
              moveList[n[0]].l = 3;
              moveList[n[0]].path[1] = (sq-8);
              m = (WHITE|MAN); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
              m = b[sq-4]; m = m << 8; m += (sq-4); moveList[n[0]].m[2] = m;
              if (sq <= 17) {
                m = (WHITE|KING); m = m << 8; m += (sq-8); moveList[n[0]].m[1] = m;
                tmp = b[sq-4]; b[sq-4] = OCCUPIED;
                whiteKingCapture(n, moveList, sq-8);
                b[sq-4] = tmp;
              } else {
                m = (WHITE|MAN); m = m << 8; m += (sq-8); moveList[n[0]].m[1] = m;
                tmp = b[sq-4]; b[sq-4] = OCCUPIED;
                whiteManCapture(n, moveList, sq-8);
                b[sq-4] = tmp;
              }
            }
          }
          if ((b[sq-5] & BLACK) != 0) {
            if (b[sq-10] & FREE ) {
              moveList[n[0]].l = 3;
              moveList[n[0]].path[1] = (sq-10);
              m = (WHITE|MAN); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
              m = b[sq-5]; m = m << 8; m += (sq-5); moveList[n[0]].m[2] = m;
              if (sq <= 17) {
                m = (WHITE|KING); m = m << 8; m += (sq-10); moveList[n[0]].m[1] = m;
                tmp = b[sq-5]; b[sq-5] = OCCUPIED;
                whiteKingCapture(n, moveList, sq-10);
                b[sq-5] = tmp;
              } else {
                m = (WHITE|MAN); m = m << 8; m += (sq-10); moveList[n[0]].m[1] = m;
                tmp = b[sq-5]; b[sq-5] = OCCUPIED;
                whiteManCapture(n, moveList, sq-10);
                b[sq-5] = tmp;
              }
            }
          } b[sq] = (WHITE|MAN);
        }
        if ((b[sq] & KING) != 0) {
          b[sq] = FREE;
          temp = sq;
          foundPd = 0;
          do temp += 4
          while((b[temp] & FREE) != 0);
          if ((b[temp] & BLACK) != 0) {
            capSq = temp;
            temp += 4;
            while((b[temp] & FREE) != 0) {
              if (testFrom13w(temp)) {
                foundPd = 1;
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (WHITE|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (WHITE|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                whiteKingCapture(n, moveList, temp);
                b[capSq] = tmp;
              } temp += 4;
            }
            if (!foundPd) {
              temp = capSq;
              temp += 4;
              while((b[temp] & FREE) != 0) {
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (WHITE|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (WHITE|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                whiteKingCapture(n, moveList, temp);
                b[capSq] = tmp;
                temp += 4;
              }
            }
          }
          temp = sq;
          foundPd = 0;
          do temp += 5
          while((b[temp] & FREE) != 0);
          if ((b[temp] & BLACK) != 0) {
            capSq = temp;
            temp += 5;
            while((b[temp] & FREE) != 0) {
              if (testFrom02w(temp)) {
                foundPd = 1;
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (WHITE|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (WHITE|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                whiteKingCapture(n, moveList, temp);
                b[capSq] = tmp;
              } temp += 5;
            }
            if (!foundPd) {
              temp = capSq;
              temp += 5;
              while((b[temp] & FREE) != 0) {
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (WHITE|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (WHITE|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                whiteKingCapture(n, moveList, temp);
                b[capSq] = tmp;
                temp += 5;
              }
            }
          }
          temp = sq;
          foundPd = 0;
          do temp -= 4
          while((b[temp] & FREE) != 0);
          if ((b[temp] & BLACK) != 0) {
            capSq = temp;
            temp -= 4;
            while((b[temp] & FREE) != 0) {
              if (testFrom13w(temp)) {
                foundPd = 1;
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (WHITE|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (WHITE|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                whiteKingCapture(n, moveList, temp);
                b[capSq] = tmp;
              } temp -= 4;
            }
            if (!foundPd) {
              temp = capSq;
              temp -= 4;
              while((b[temp] & FREE) != 0) {
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (WHITE|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (WHITE|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                whiteKingCapture(n, moveList, temp);
                b[capSq] = tmp;
                temp -= 4;
              }
            }
          }
          temp = sq;
          foundPd = 0;
          do temp -= 5
          while((b[temp] & FREE) != 0);
          if ((b[temp] & BLACK) != 0) {
            capSq = temp;
            temp -= 5;
            while((b[temp] & FREE) != 0) {
              if (testFrom02w(temp)) {
                foundPd = 1;
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (WHITE|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (WHITE|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                whiteKingCapture(n, moveList, temp);
                b[capSq] = tmp;
              } temp -= 5;
            }
            if (!foundPd) {
              temp = capSq;
              temp -= 5;
              while((b[temp] & FREE) != 0) {
                moveList[n[0]].l = 3;
                moveList[n[0]].path[1] = temp;
                m = (WHITE|KING); m = m << 8; m += temp; moveList[n[0]].m[1] = m;
                m = (WHITE|KING); m = m << 8; m += sq; moveList[n[0]].m[0] = m;
                m = b[capSq]; m = m << 8; m += capSq; moveList[n[0]].m[2] = m;
                tmp = b[capSq]; b[capSq] = OCCUPIED;
                whiteKingCapture(n, moveList, temp);
                b[capSq] = tmp;
                temp -= 5;
              }
            }
          } b[sq] = (WHITE|KING);
        }
      }
    }
  } return n[0];
}

function testFrom13b(mloc) {
  let sq;
  sq = mloc;
  do sq += 5;
  while((b[sq] & FREE) != 0);
  if ((b[sq] & WHITE) != 0)
    if ((b[sq+5] & FREE) != 0)
      return 1;
  sq = mloc;
  do sq -= 5;
  while((b[sq] & FREE) != 0);
  if ((b[sq] & WHITE) != 0)
    if ((b[sq-5] & FREE) != 0)
      return 1;
  return 0;
}

function testFrom02b(mloc) {
  let sq;
  sq = mloc;
  do sq += 4;
  while((b[sq] & FREE) != 0);
  if ((b[sq] & WHITE) != 0)
    if ((b[sq+4] & FREE) != 0)
      return 1;
  sq = mloc;
  do sq -= 4;
  while((b[sq] & FREE) != 0);
  if ((b[sq] & WHITE) != 0)
    if ((b[sq-4] & FREE) != 0)
      return 1;
  return 0;
}

function testFrom13w(mloc) {
  let sq;
  sq = mloc;
  do sq += 5;
  while((b[sq] & FREE) != 0);
  if ((b[sq] & BLACK) != 0)
    if ((b[sq+5] & FREE) != 0)
      return 1;
  sq = mloc;
  do sq -= 5;
  while((b[sq] & FREE) != 0);
  if ((b[sq] & BLACK) != 0)
    if ((b[sq-5] & FREE) != 0)
      return 1;
  return 0;
}

function testFrom02w(mloc) {
  let sq;
  sq = mloc;
  do sq += 4;
  while((b[sq] & FREE) != 0);
  if ((b[sq] & BLACK) != 0)
    if ((b[sq+4] & FREE) != 0)
      return 1;
  sq = mloc;
  do sq -= 4;
  while((b[sq] & FREE) != 0);
  if ((b[sq] & BLACK) != 0)
    if ((b[sq-4] & FREE) != 0)
      return 1;
  return 0;
}

function blackManCapture(n, moveList, j) {
  let m, temp, tmp;
  let foundCap = 0;
  let move, orgMove;
  orgMove = structuredClone(moveList[n[0]]);
  if ((b[j+4] & WHITE) != 0) {
    if (b[j+8] & FREE ) {
      move = structuredClone(orgMove);
      move.l++;
      move.path[move.l-2] = (j+8);
      m = b[j+4]; m = m << 8; m += (j+4); move.m[move.l-1] = m;
      if (j >= 28) {
        m = (BLACK|KING); m = m << 8; m += (j+8); move.m[1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[j+4]; b[j+4] = OCCUPIED;
        blackKingCapture(n, moveList, j+8);
        b[j+4] = tmp;
      } else {
        m = (BLACK|MAN); m = m << 8; m += (j+8); move.m[1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[j+4]; b[j+4] = OCCUPIED;
        blackManCapture(n, moveList, j+8);
        b[j+4] = tmp;
      }
    }
  }
  if ((b[j+5] & WHITE) != 0) {
    if (b[j+10] & FREE ) {
      move = structuredClone(orgMove);
      move.l++;
      move.path[move.l-2] = (j+10);
      m = b[j+5]; m = m << 8; m += (j+5); move.m[move.l-1] = m;
      if (j >= 28) {
        m = (BLACK|KING); m = m << 8; m += (j+10); move.m[1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[j+5]; b[j+5] = OCCUPIED;
        blackKingCapture(n, moveList, j+10);
        b[j+5] = tmp;
      } else {
        m = (BLACK|MAN); m = m << 8; m += (j+10); move.m[1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[j+5]; b[j+5] = OCCUPIED;
        blackManCapture(n, moveList, j+10);
        b[j+5] = tmp;
      }
    }
  }
  if ((b[j-4] & WHITE) != 0) {
    if (b[j-8] & FREE ) {
      move = structuredClone(orgMove);
      move.l++;
      move.path[move.l-2] = (j-8);
      m = (BLACK|MAN); m = m << 8; m += (j-8); move.m[1] = m;
      m = b[j-4]; m = m << 8; m += (j-4); move.m[move.l-1] = m;
      foundCap = 1;
      moveList[n[0]] = structuredClone(move);
      tmp = b[j-4]; b[j-4] = OCCUPIED;
      blackManCapture(n, moveList, j-8);
      b[j-4] = tmp;
    }
  }
  if ((b[j-5] & WHITE) != 0) {
    if (b[j-10] & FREE ) {
      move = structuredClone(orgMove);
      move.l++;
      move.path[move.l-2] = (j-10);
      m = (BLACK|MAN); m = m << 8; m += (j-10); move.m[1] = m;
      m = b[j-5]; m = m << 8; m += (j-5); move.m[move.l-1] = m;
      foundCap = 1;
      moveList[n[0]] = structuredClone(move);
      tmp = b[j-5]; b[j-5] = OCCUPIED;
      blackManCapture(n, moveList, j-10);
      b[j-5] = tmp;
    }
  } if (!foundCap) n[0]++;
}

function blackKingCapture(n, moveList, j) {
  let m, temp, tmp, capSq, foundPd;
  let foundCap = 0;
  let move, orgMove;
  orgMove = structuredClone(moveList[n[0]]);
  temp = j;
  foundPd = 0;
  do temp += 4;
  while((b[temp] & FREE) != 0);
  if ((b[temp] & WHITE) != 0) {
    capSq = temp;
    temp += 4;
    while ((b[temp] & FREE) != 0) {
      if (testFrom13b(temp)) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (BLACK|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundPd = 1;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        blackKingCapture(n, moveList, temp);
        b[capSq] = tmp;
      } temp += 4;
    }
    if (!foundPd) {
      temp = capSq;
      temp += 4;
      while((b[temp] & FREE) != 0) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (BLACK|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        blackKingCapture(n, moveList, temp);
        b[capSq] = tmp;
        temp += 4;
      }
    }
  }
  temp = j;
  foundPd = 0;
  do temp += 5;
  while((b[temp] & FREE) != 0);
  if ((b[temp] & WHITE) != 0) {
    capSq = temp;
    temp += 5;
    while ((b[temp] & FREE) != 0) {
      if (testFrom02b(temp)) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (BLACK|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundPd = 1;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        blackKingCapture(n, moveList, temp);
        b[capSq] = tmp;
      } temp += 5;
    }
    if (!foundPd) {
      temp = capSq;
      temp += 5;
      while((b[temp] & FREE) != 0) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (BLACK|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        blackKingCapture(n, moveList, temp);
        b[capSq] = tmp;
        temp += 5;
      }
    }
  }
  temp = j;
  foundPd = 0;
  do temp -= 4;
  while((b[temp] & FREE) != 0);
  if ((b[temp] & WHITE) != 0) {
    capSq = temp;
    temp -= 4;
    while ((b[temp] & FREE) != 0) {
      if (testFrom13b(temp)) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (BLACK|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundPd = 1;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        blackKingCapture(n, moveList, temp);
        b[capSq] = tmp;
      } temp -= 4;
    }
    if (!foundPd) {
      temp = capSq;
      temp -= 4;
      while((b[temp] & FREE) != 0) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (BLACK|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        blackKingCapture(n, moveList, temp);
        b[capSq] = tmp;
        temp -= 4;
      }
    }
  }
  temp = j;
  foundPd = 0;
  do temp -= 5;
  while((b[temp] & FREE) != 0);
  if ((b[temp] & WHITE) != 0) {
    capSq = temp;
    temp -= 5;
    while ((b[temp] & FREE) != 0) {
      if (testFrom02b(temp)) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (BLACK|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundPd = 1;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        blackKingCapture(n, moveList, temp);
        b[capSq] = tmp;
      } temp -= 5;
    }
    if (!foundPd) {
      temp = capSq;
      temp -= 5;
      while((b[temp] & FREE) != 0) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (BLACK|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        blackKingCapture(n, moveList, temp);
        b[capSq] = tmp;
        temp -= 5;
      }
    }
  } if (!foundCap) n[0]++;
}


function whiteManCapture(n, moveList, j) {
  let m, temp, tmp;
  let foundCap = 0;
  let move, orgMove;
  orgMove = structuredClone(moveList[n[0]]);
  if ((b[j+4] & BLACK) != 0) {
    if (b[j+8] & FREE ) {
      move = structuredClone(orgMove);
      move.l++;
      move.path[move.l-2] = (j+8);
      m = (WHITE|MAN); m = m << 8; m += (j+8); move.m[1] = m;
      m = b[j+4]; m = m << 8; m += (j+4); move.m[move.l-1] = m;
      foundCap = 1;
      moveList[n[0]] = structuredClone(move);
      tmp = b[j+4]; b[j+4] = OCCUPIED;
      whiteManCapture(n, moveList, j+8);
      b[j+4] = tmp;
    }
  }
  if ((b[j+5] & BLACK) != 0) {
    if (b[j+10] & FREE ) {
      move = structuredClone(orgMove);
      move.l++;
      move.path[move.l-2] = (j+10);
      m = (WHITE|MAN); m = m << 8; m += (j+10); move.m[1] = m;
      m = b[j+5]; m = m << 8; m += (j+5); move.m[move.l-1] = m;
      foundCap = 1;
      moveList[n[0]] = structuredClone(move);
      tmp = b[j+5]; b[j+5] = OCCUPIED;
      whiteManCapture(n, moveList, j+10);
      b[j+5] = tmp;
    }
  }
  if ((b[j-4] & BLACK) != 0) {
    if (b[j-8] & FREE ) {
      move = structuredClone(orgMove);
      move.l++;
      move.path[move.l-2] = (j-8);
      m = b[j-4]; m = m << 8; m += (j-4); move.m[move.l-1] = m;
      if (j <= 17) {
        m = (WHITE|KING); m = m << 8; m += (j-8); move.m[1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[j-4]; b[j-4] = OCCUPIED;
        whiteKingCapture(n, moveList, j-8);
        b[j-4] = tmp;
      } else {
        m = (WHITE|MAN); m = m << 8; m += (j-8); move.m[1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[j-4]; b[j-4] = OCCUPIED;
        whiteManCapture(n, moveList, j-8);
        b[j-4] = tmp;
      }
    }
  }
  if ((b[j-5] & BLACK) != 0) {
    if (b[j-10] & FREE ) {
      move = structuredClone(orgMove);
      move.l++;
      move.path[move.l-2] = (j-10);
      m = b[j-5]; m = m << 8; m += (j-5); move.m[move.l-1] = m;
      if (j <= 17) {
        m = (WHITE|KING); m = m << 8; m += (j-10); move.m[1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[j-5]; b[j-5] = OCCUPIED;
        whiteKingCapture(n, moveList, j-10);
        b[j-5] = tmp;
      } else {
        m = (WHITE|MAN); m = m << 8; m += (j-10); move.m[1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[j-5]; b[j-5] = OCCUPIED;
        whiteManCapture(n, moveList, j-10);
        b[j-5] = tmp;
      }
    }
  } if (!foundCap) n[0]++;
}

function whiteKingCapture(n, moveList, j) {
  let m, temp, tmp, capSq, foundPd;
  let foundCap = 0;
  let move, orgMove;
  orgMove = structuredClone(moveList[n[0]]);
  temp = j;
  foundPd = 0;
  do temp += 4;
  while((b[temp] & FREE) != 0);
  if ((b[temp] & BLACK) != 0) {
    capSq = temp;
    temp += 4;
    while ((b[temp] & FREE) != 0) {
      if (testFrom13w(temp)) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (WHITE|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundPd = 1;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        whiteKingCapture(n, moveList, temp);
        b[capSq] = tmp;
      } temp += 4;
    }
    if (!foundPd) {
      temp = capSq;
      temp += 4;
      while((b[temp] & FREE) != 0) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (WHITE|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        whiteKingCapture(n, moveList, temp);
        b[capSq] = tmp;
        temp += 4;
      }
    }
  }
  temp = j;
  foundPd = 0;
  do temp += 5;
  while((b[temp] & FREE) != 0);
  if ((b[temp] & BLACK) != 0) {
    capSq = temp;
    temp += 5;
    while ((b[temp] & FREE) != 0) {
      if (testFrom02w(temp)) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (WHITE|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundPd = 1;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        whiteKingCapture(n, moveList, temp);
        b[capSq] = tmp;
      } temp += 5;
    }
    if (!foundPd) {
      temp = capSq;
      temp += 5;
      while((b[temp] & FREE) != 0) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (WHITE|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        whiteKingCapture(n, moveList, temp);
        b[capSq] = tmp;
        temp += 5;
      }
    }
  }
  temp = j;
  foundPd = 0;
  do temp -= 4;
  while((b[temp] & FREE) != 0);
  if ((b[temp] & BLACK) != 0) {
    capSq = temp;
    temp -= 4;
    while ((b[temp] & FREE) != 0) {
      if (testFrom13w(temp)) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (WHITE|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundPd = 1;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        whiteKingCapture(n, moveList, temp);
        b[capSq] = tmp;
      } temp -= 4;
    }
    if (!foundPd) {
      temp = capSq;
      temp -= 4;
      while((b[temp] & FREE) != 0) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (WHITE|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        whiteKingCapture(n, moveList, temp);
        b[capSq] = tmp;
        temp -= 4;
      }
    }
  }
  temp = j;
  foundPd = 0;
  do temp -= 5;
  while((b[temp] & FREE) != 0);
  if ((b[temp] & BLACK) != 0) {
    capSq = temp;
    temp -= 5;
    while ((b[temp] & FREE) != 0) {
      if (testFrom02w(temp)) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (WHITE|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundPd = 1;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        whiteKingCapture(n, moveList, temp);
        b[capSq] = tmp;
      } temp -= 5;
    }
    if (!foundPd) {
      temp = capSq;
      temp -= 5;
      while((b[temp] & FREE) != 0) {
        move = structuredClone(orgMove);
        move.l++;
        move.path[move.l-2] = temp;
        m = (WHITE|KING); m = m << 8; m += temp; move.m[1] = m;
        m = b[capSq]; m = m << 8; m += capSq; move.m[move.l-1] = m;
        foundCap = 1;
        moveList[n[0]] = structuredClone(move);
        tmp = b[capSq]; b[capSq] = OCCUPIED;
        whiteKingCapture(n, moveList, temp);
        b[capSq] = tmp;
        temp -= 5;
      }
    }
  } if (!foundCap) n[0]++;
}

function makeMove(move) {
  let sq, after;
  sq = move.m[0] & 255;
  b[sq] = FREE;
  sq = move.m[1] & 255;
  after = (move.m[1] >> 8);
  b[sq]=after;
  for (let i = 2; i < move.l; i++) {
    sq = (move.m[i] & 255);
    b[sq] = FREE;
  } ply++;
}

function undoMove(move) {
  let sq, before;
  sq = move.m[1] & 255;
  b[sq] = FREE;
  sq = move.m[0] & 255;
  before = (move.m[0] >> 8);
  b[sq] = before;
  for (let i = 2; i < move.l; i++) {
    sq = (move.m[i] & 255);
    before = (move.m[i] >> 8);
    b[sq] = before;
  } ply--;
}

function perftDriver(depth, color) {
  if (depth == 0) { nodes++; return; }
  let n, moveList;
  moveList = createMoveList();
  n = generateCaptures(moveList, color);
  if (!n) n = generateQuiets(moveList, color);
  for (let i = 0; i < n; i++) {
    makeMove(moveList[i]); //printBoard();
    perftDriver(depth-1, color^CHANGECOLOR);
    undoMove(moveList[i]); //printBoard();
  }
}

function perftTest(depth, color) {
  nodes = 0;
  console.log('\n    Performance test:\n\n');
  printBoard();
  console.log('Side to move: ' + (color == 2 ? 'black' : 'white'));
  let resultString = '';
  let startTime = Date.now();
  let n, moveList;
  moveList = createMoveList();
  n = generateCaptures(moveList, color);
  if (!n) n = generateQuiets(moveList, color);
  for (let i = 0; i < n; i++) {
    makeMove(moveList[i]);
    let cumNodes = nodes;
    perftDriver(depth-1, color^CHANGECOLOR);
    undoMove(moveList[i]);
    let oldNodes = nodes - cumNodes;
    console.log('Move: ' + move2str(moveList[i]) + ', nodes: ' + oldNodes);
  } resultString += '\n    Time: ' + (Date.now() - startTime) + ' ms';
  resultString += '\n   Depth: ' + depth;
  resultString += '\n   Nodes: ' + nodes;
  console.log(resultString);
}

function perftTestSuit(depth) {
  let color = [0];
  parseFen(startFen, color);
  perftTest(depth, color);
  for (let fen of testPositions) {
    parseFen(fen, color);
    perftTest(depth, color);
  }
}

function sortMoves(currentCount, moveList) {
  for (let nextCount = currentCount + 1; nextCount < moveList.length; nextCount++) {
    if (moveList[currentCount].score < moveList[nextCount].score) {
      let tempMove = moveList[currentCount];
      moveList[currentCount] = moveList[nextCount];
      moveList[nextCount] = tempMove;
    }
  }
}

function clearSearch() {
  nodes = 0; ply = 0;
  for (let index = 0; index < killerMoves.length; index++) killerMoves[index] = 0;
}

function evaluate(color) {
  let score = 0;
  for (let sq = 5; sq <= 40; sq++) {
    score += pieceScores[b[sq]];
    switch (b[sq]) {
      case 5: score += pst[sq]; break;
      case 6: score -= pst[sq]; break;
      case 9: score += pst[sq]; break;
      case 10: score -= pst[sq]; break;
    }
  } return (color == WHITE) ? score : -score;
}

function quiescence(alpha, beta, color) {
  nodes++;
  let standPat = evaluate(color);
  if (standPat >= beta) return standPat;
  if (standPat > alpha) alpha = standPat;
  let n, moveList;
  moveList = createMoveList();
  n = generateCaptures(moveList, color);
  if (n == 0) return standPat;
  for (let i = 0; i < n; i++) {
    makeMove(moveList[i]);
    let score = -quiescence(-beta, -alpha, color^CHANGECOLOR);
    undoMove(moveList[i]);
    if (score >= beta) return score;
    if (score > alpha) alpha = score;
  } return alpha;
}
  
function negamax(depth, alpha, beta, originalDepth, color, bestMove) {
  if (depth === 0) return quiescence(alpha, beta, color);
  let localPly = originalDepth - depth;
  let n, moveList;
  moveList = createMoveList();
  n = generateCaptures(moveList, color);
  if (!n) n = generateQuiets(moveList, color);
  for (let i = 0; i < n; i++) {
    if (moveList[i].l <= 2) {
      if (killerMoves[ply].l == moveList[i].l &&
          killerMoves[ply].m[0] == moveList[i].m[0] &&
          killerMoves[ply].m[1] == moveList[i].m[1]) moveList[i].score = 9000;
      else if (killerMoves[MAXPLY + ply].l == moveList[i].l &&
          killerMoves[MAXPLY + ply].m[0] == moveList[i].m[0] &&
          killerMoves[MAXPLY + ply].m[1] == moveList[i].m[1]) moveList[i].score = 8000;
      else if (bestMove[0].l == moveList[i].l &&
               bestMove[0].m[0] == moveList[i].m[0] &&
               bestMove[0].m[1] == moveList[i].m[1]) moveList[i].score = 10000;
    }
  }
  if (!n) return -WIN + localPly;
  for (let i = 0; i < n; i++) {
    sortMoves(i, moveList);
    makeMove(moveList[i]);
    let cumNodes = nodes;
    let score  = -negamax(depth - 1, -beta, -alpha, originalDepth, color^CHANGECOLOR, bestMove);
    undoMove(moveList[i]);
    let oldNodes = nodes - cumNodes;
    if (score > alpha) {
      if (score >= beta) {
        if (moveList[i].l <= 2) {
          killerMoves[MAXPLY + ply] = killerMoves[ply];
          killerMoves[ply] = moveList[i];
        } return beta;
      } alpha = score;
      if (depth === originalDepth) bestMove[0] = structuredClone(moveList[i]);
    }
  } return alpha;
}

function search(depth, color) {
  nodes = 0;
  let bestMove = [createMove()];
  let bestScore = null;
  let colorString = (color == 2 ? 'black' : 'white');
  console.log('Searching for ' + colorString);
  for (let currentDepth = 1; currentDepth <= depth; currentDepth++) {
    let originalDepth = currentDepth;
    bestScore = negamax(currentDepth, -INFINITY, INFINITY, originalDepth, color, bestMove);
    let printScore = '';
    let printMove = 'move ' + (move2str(bestMove[0]) == 'b8-b8' ? 'none' : move2str(bestMove[0]));
    let printNodes = ' nodes ' + nodes;
    let printDepth = ' depth ' + currentDepth;
    if (Math.abs(bestScore) >= 9000) {
      let winIn = (bestScore > 0) ? (WIN - bestScore) : (WIN + bestScore);
      if (bestScore > 0) printScore = ` win in ${winIn} ply`;
      else printScore = ` loss in ${winIn} ply`;
    } else printScore = ` score ${bestScore}`;
    console.log(printMove + printDepth + printScore + printNodes);
    if (currentDepth == depth) print(printMove + printDepth + printScore);
  }
  return bestMove[0];
}

function makeEngineMove() {
  if (edit) return;
  clearSearch();
  let move = search(searchDepth, side[0]);
  makeMove(move);
  gameMoves.push(move);
  side[0] ^= CHANGECOLOR;
  drawBoard();
  let m = move2str(move).replace('x', '-');
  let src = m.split('-')[0];
  let sr = 8-parseInt(src[1]);
  let sc = 7-'abcdefgh'.indexOf(src[0]);
  document.getElementById(sc + ':' + sr).classList.add('highlight');
  let dst = m.split('-')[1];
  let dr = 8-parseInt(dst[1]);
  let dc = 7-'abcdefgh'.indexOf(dst[0]);
  document.getElementById(dc + ':' + dr).classList.add('highlight');
}

function drawBoard() {
  brd2dsp();
  let boardHTML = `<table align="center" cellspacing="0" `;
  boardHTML += `style=" -moz-user-select: none; -webkit-user-select: none; -ms-user-select: none;`;
  boardHTML += `user-select: none; -o-user-select: none;`;
  boardHTML += `unselectable="on" onselectstart="return false;" onmousedown="return false;"`;
  for (let row = 0; row < 8; row++) {
    boardHTML+= '<tr>';
    for (let col = 0; col < 8; col++) {
      let file, rank;
      if (flip) {
        file = 7-col;
        rank = 7-row;
      } else {
        file = col;
        rank = row;
      } let piece;
      let sq = (7-file) + ':' + rank;
      let pce = board[7-file][rank];
      switch(pce) {
        case 5: piece = whiteMan; break;
        case 6: piece = blackMan; break;
        case 9: piece = whiteKing; break;
        case 10: piece = blackKing; break;
        case 16: piece = emptySq; break;
      } boardHTML+= '<td align="center" id="' + sq +
        '"bgcolor="#' + ( ((col + row) % 2) ? '999999' : 'eef2e1') + '" style="width: ' + size +
        'px; height: ' + size + 'px; padding: 0px; font-size: ' + (size/2) + 'px; border: 1px solid black;"' +
        ' onclick="userMove(this.id)">' + piece + '</td>';
    } boardHTML+= '</tr>';
  } boardHTML+= '</table>';
  document.getElementById('board').innerHTML = boardHTML;
  let boardWidth = (document.getElementById('board').offsetWidth) + 'px';
  document.getElementById('fen').style = 'width: ' + boardWidth +
  '; font-size: inherit; text-align: center; height: 50px; margin-top: 10px;';
  document.getElementById('out').style = 'width: ' + boardWidth +
  '; font-size: inherit; height: 100%; overflow: hidden; margin-top: 10px; margin-bottom: 10px;; border: 1px solid black;';
  document.getElementById('buttons').style.width = boardWidth;
}

function userMove(coord) {
  let row = parseInt(coord.split(':')[0]);
  let col = parseInt(coord.split(':')[1]);
  if (clickLock && board[row][col] != 16) clickLock = 0;
  if(!clickLock && board[row][col] != 16) {
    if ((board[row][col] & CHANGECOLOR) != side[0]) return;
    for (let row = 0; row < 8; row++)
      for (let col = 0; col < 8; col++)
        document.getElementById(row+':'+col).classList.remove('highlight');
    document.getElementById(coord).classList.add('highlight');
    legalMoves = [];
    let color = board[row][col] & CHANGECOLOR;
    let n, moveList;
    moveList = createMoveList();
    n = generateCaptures(moveList, color);
    if (!n) n = generateQuiets(moveList, color);
    let src = 'abcdefgh'[7-row] + '12345678'[7-col];
    for (let i = 0; i < n; i++) {
      let m = move2str(moveList[i]).replace('x', '-');
      if (src == m.split('-')[0]) {
        let dst = m.split('-')[1];
        let dr = 8-parseInt(dst[1]);
        let dc = 7-'abcdefgh'.indexOf(dst[0]);
        legalMoves.push({'dst': dst, 'm': moveList[i]});
        document.getElementById(dc + ':' + dr).classList.add('highlight');
        usrSrc = [row, col];
      }
    } clickLock = 1;
  }
  if(clickLock && board[row][col] == 16) {
    let dst = 'abcdefgh'[7-row] + '12345678'[7-col];
    for (let move of legalMoves) {
      if (move.dst == dst) {
        makeMove(move.m);
        gameMoves.push(move.m);
        side[0] ^= CHANGECOLOR;
        setTimeout(function() { makeEngineMove(); }, 100);
        break;
      }
    } clickLock = 0;
    drawBoard();
  }
}

document.getElementById('fen').addEventListener('keypress', (e) => {
  if (e.key == 'Enter') {
    try {
      parseFen(document.getElementById('fen').value, side);
      drawBoard();
    } catch(e) {}
  }
});

document.getElementById('depth').addEventListener('change', () => {
  let newDepth = document.getElementById('depth').value;
  searchDepth = parseInt(newDepth);
});

document.getElementById('play').addEventListener('click', () => {
  window.location.reload();
});

document.getElementById('edit').addEventListener('click', () => {
  edit ^= 1; alert('Edit mode is ' + (edit ? 'on' : 'off'));
});

document.getElementById('undo').addEventListener('click', () => {
  if (!gameMoves.length) return;
  let lastMove = gameMoves[gameMoves.length-1];
  undoMove(lastMove);
  side[0] ^= CHANGECOLOR;
  gameMoves.pop();
  drawBoard();
});

document.getElementById('move').addEventListener('click', () => {
  edit = 0;
  makeEngineMove();
});

document.getElementById('flip').addEventListener('click', () => {
  flip ^= 1;
  drawBoard();
});

parseFen(startFen, side);
drawBoard();

</script>
</body>
</html>
